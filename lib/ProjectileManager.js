/* * Ludum Dare 29 * Tustin2121 & MaverickLoneshark */  (function() {	var TRAIL_LENGTH = 8;	var PLAYER_SPEED = 1;	var ENEMY_SPEED = 0.5;		function Projectile(type, x, y, x_vel, y_vel, active)	{		this.type = type;		this.x = new Array();		this.y = new Array();				var date = new Date();		this.birth = date.getTime();				this.x[0] = x;		this.y[0] = y;		this.x_vel = x_vel;		this.y_vel = y_vel;		this.x_dest;		this.y_dest;		this.active = active;				return;	}		Projectile.prototype.detonate = function()	{		this.type = 9;		this.morph = 0;				var date = new Date();		this.birth = date.getTime();				ldGame.sound_manager.playSound("snd/explosion.wav");				return;	}		Projectile.prototype.radialCollision = function(x, y, radius)	{		var delta_x = x - this.x[0];		var delta_y = y - this.y[0];		var distance_squared = (delta_x * delta_x) + (delta_y * delta_y);				if(distance_squared <= (radius * radius))		{			return true;		}				return false;	}		function ProjectileManager()	{		this.projectiles = new Array();		this.ready_index = 0;				for(var i = 0; i < 100; i++)		{			this.projectiles[i] = new Projectile();			this.projectiles[i].active = false;		}				return;	}		/********************************************************************	If x_vel & y_vel are provided then x & y serve as origin coordinates.	Otherwise, x & y serve as destination coordinates.	*********************************************************************/	ProjectileManager.prototype.initializeProjectile = function(type, x, y, x_vel, y_vel)	{		if(!x_vel)		{			//get nearest turret coords			var turret = ldGame.game_manager.getNearestBuilding(Outpost, x, y);						var x_component = x - turret.x;			var y_component = y - turret.y;			var distance_squared = (x_component * x_component) + (y_component * y_component);			x_component /= Math.sqrt(distance_squared);			y_component /= Math.sqrt(distance_squared);		}				if(!this.projectiles[this.ready_index].active)		{			if(x_vel)			{				fire(this.projectiles[this.ready_index], type, x, y, x_vel, y_vel, 0, 0);			}			else			{				fire(this.projectiles[this.ready_index], type, turret.x, turret.y, x_component, y_component, x, y);			}						//update ready_index to next element			this.ready_index = (this.ready_index + 1) % this.projectiles.length;						return;		}				var next = this.ready_index + 1;				while(next != this.ready_index)		{			if(!this.projectiles[next].active)			{				if(x_vel)				{					fire(this.projectiles[next], type, x, y, x_vel, y_vel, 0, 0);				}				else				{					fire(this.projectiles[next], type, turret.x, turret.y, x_component, y_component, x, y);				}								//set ready_index to the next element				this.ready_index = (next + 1) % this.projectiles.length;								return;			}						next = (next + 1) % this.projectiles.length;		}				//dynamically allocate more memory for pool since it is full!		this.projectiles[this.projectiles.length] = new Projectile(type, x, y, x_vel, y_vel, true);				if(x_vel)		{			fire(this.projectiles[this.projectiles.length - 1], type, x, y, x_vel, y_vel, 0, 0);		}		else		{			fire(this.projectiles[this.projectiles.length - 1], type, turret.x, turret.y, x_component, y_component, x, y);		}				//reset ready_index to 0 and hope an earlier projectile deactivates		this.ready_index = 0;				function fire(projectile, type, x, y, x_vel, y_vel, x_dest, y_dest)		{			projectile.type = type;						for(var i = 0; i < TRAIL_LENGTH; i++)			{				projectile.x[i] = x;				projectile.y[i] = y;			}						if(!projectile.type)			{				projectile.x_vel = x_vel * PLAYER_SPEED;				projectile.y_vel = y_vel * PLAYER_SPEED;			}			else			{				projectile.x_vel = x_vel * ENEMY_SPEED;				projectile.y_vel = y_vel * ENEMY_SPEED;			}						projectile.x_dest = x_dest;			projectile.y_dest = y_dest;						//track projectile age			var date = new Date();			projectile.birth = date.getTime();			projectile.morph = (Math.random() * 1000) + 250;						projectile.active = true;						return;		}				return;	}		ProjectileManager.prototype.collisionDetection = function(deltaTime)	{		for(var m = 0; m < (this.projectiles.length - 1); m++)		{			var missile = this.projectiles[m];						if(missile.active)			{				//check for collisions against other projectiles				for(var r = m + 1; r < this.projectiles.length; r++)				{					var rocket = this.projectiles[r];										if(rocket.active)					{						if((missile.type != 9) && (rocket.type != 9)) //neither projectile has detonated yet						{							if(missile.radialCollision(rocket.x[0], rocket.y[0], 4)) //check against undetonated projectiles							{								missile.detonate(); //both projectiles will detonate								rocket.detonate();							}						}						else if(rocket.type != 9) //rocket will check against missile explosions						{							if(rocket.radialCollision(missile.x[0], missile.y[0], missile.morph))							{								rocket.detonate(); //rocket detonates if caught in missile explosion							}						}						else if(missile.type != 9) //missile will check against rocket explosions						{							if(missile.radialCollision(rocket.x[0], rocket.y[0], rocket.morph))							{								missile.detonate(); //missile detonates if caught in rocket explosion							}						}					}				}								//check for collisions against structures			}		}				return;	}		ProjectileManager.prototype.update = function(deltaTime)	{		for(var m = 0; m < this.projectiles.length; m++)		{			if(this.projectiles[m].active)			{				//contrail				for(i = TRAIL_LENGTH - 1; i > 0; i--)				{					this.projectiles[m].x[i] = this.projectiles[m].x[i - 1];					this.projectiles[m].y[i] = this.projectiles[m].y[i - 1];				}								//do this.projectiles[m].update() here				switch(this.projectiles[m].type)				{					case 0:						//player projectiles detonate upon reaching destination (become Explosions)						var change_x = this.projectiles[m].x_dest - this.projectiles[m].x[0];						var change_y = this.projectiles[m].y_dest - this.projectiles[m].y[0];						var distance = Math.sqrt((change_x * change_x) + (change_y * change_y));												if(distance <= 8)						{							this.projectiles[m].detonate();						}					case 1: //B.A.S.I.C. Missiles						this.projectiles[m].x[0] += (this.projectiles[m].x_vel * deltaTime);						this.projectiles[m].y[0] += (this.projectiles[m].y_vel * deltaTime);					break;										case 2: //ARK Missiles						this.projectiles[m].x[0] += (this.projectiles[m].x_vel * deltaTime);						this.projectiles[m].y[0] += (this.projectiles[m].y_vel * deltaTime);												var date = new Date();						var timestamp = date.getTime();												if((this.projectiles[m].birth + this.projectiles[m].morph) < timestamp)						{							this.projectiles[m].x_vel = -this.projectiles[m].x_vel;							this.projectiles[m].birth = timestamp;						}					break;										case 3:											break;										case 9: //Explosion							var date = new Date();							this.projectiles[m].morph = (date.getTime() - this.projectiles[m].birth) / 23;														if((date.getTime() - this.projectiles[m].birth) > 750)							{								this.projectiles[m].active = false;								ldGame.canvas_manager.redrawAll(true);							}					default:					break;				}								if((this.projectiles[m].x[TRAIL_LENGTH - 1] < 0) || (this.projectiles[m].x[TRAIL_LENGTH - 1] > 1024)||					(this.projectiles[m].y[TRAIL_LENGTH - 1] < 0) || (this.projectiles[m].y[TRAIL_LENGTH - 1] > 12 * 256))				{					this.projectiles[m].active = false;					ldGame.canvas_manager.redrawAll(true);				}			}		}				return;	}		ProjectileManager.prototype.TRAIL_LENGTH = TRAIL_LENGTH;		window.ProjectileManager = ProjectileManager;		return; })(); 