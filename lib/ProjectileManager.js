/* * Ludum Dare 29 * Tustin2121 & MaverickLoneshark */  (function() {	var TRAIL_LENGTH = 8;	var SPEED_FACTOR = 2;		function Projectile(type, x, y, x_vel, y_vel, active)	{		this.type = type;		this.x = new Array();		this.y = new Array();				var date = new Date();		this.birth = date.getTime();				this.x[0] = x;		this.y[0] = y;		this.x_vel = x_vel;		this.y_vel = y_vel;		this.active = active;				return;	}		function ProjectileManager()	{		this.projectiles = new Array();		this.ready_index = 0;				for(var i = 0; i < 100; i++)		{			this.projectiles[i] = new Projectile();			this.projectiles[i].active = false;		}				return;	}		/********************************************************************	If x_vel & y_vel are provided then x & y serve as origin coordinates.	Otherwise, x & y serve as destination coordinates.	*********************************************************************/	ProjectileManager.prototype.initializeProjectile = function(type, x, y, x_vel, y_vel)	{		if(!this.projectiles[this.ready_index].active)		{			this.projectiles[this.ready_index].type = type;						if(x_vel)			{				//todo: get nearest turret coords				for(var i = 0; i < TRAIL_LENGTH; i++)				{					this.projectiles[this.ready_index].x[i] = x;					this.projectiles[this.ready_index].y[i] = y;				}								this.projectiles[this.ready_index].x_vel = x_vel * SPEED_FACTOR;				this.projectiles[this.ready_index].y_vel = y_vel * SPEED_FACTOR;			}			else			{				for(var i = 0; i < TRAIL_LENGTH; i++)				{					this.projectiles[this.ready_index].x[i] = 0;					this.projectiles[this.ready_index].y[i] = 0;				}								var distance_squared = ((x - 0) * (x - 0)) + ((y - 0) * (y - 0));				var x_component = x / Math.sqrt(distance_squared);				var y_component = y / Math.sqrt(distance_squared);								this.projectiles[this.ready_index].x_vel = x_component * SPEED_FACTOR;				this.projectiles[this.ready_index].y_vel = y_component * SPEED_FACTOR;			}						this.projectiles[this.ready_index].active = true;						//track projectile age			var date = new Date();			this.projectiles[this.ready_index].birth = date.getTime();			this.projectiles[this.ready_index].morph = (Math.random() * 1000) + 250;						//update ready_index to next element			this.ready_index = (this.ready_index + 1) % this.projectiles.length;						return;		}				var next = this.ready_index + 1;				while(next != this.ready_index)		{			if(!this.projectiles[next].active)			{				this.projectiles[next].type = type;								if(x_vel)				{					for(var i = 0; i < TRAIL_LENGTH; i++)					{						this.projectiles[next].x[i] = x;						this.projectiles[next].y[i] = y;					}										this.projectiles[next].x_vel = x_vel * SPEED_FACTOR;					this.projectiles[next].y_vel = y_vel * SPEED_FACTOR;				}				else				{					//todo: get nearest turret coords					for(var i = 0; i < TRAIL_LENGTH; i++)					{						this.projectiles[next].x[i] = 0;						this.projectiles[next].y[i] = 0;					}										var distance_squared = ((x - 0) * (x - 0)) + ((y - 0) * (y - 0));					var x_component = x * x / distance_squared;					var y_component = y * y / distance_squared;										this.projectiles[next].x_vel = x_component * SPEED_FACTOR;					this.projectiles[next].y_vel = y_component * SPEED_FACTOR;				}								this.projectiles[next].active = true;								//track projectile age				var date = new Date();				this.projectiles[next].birth = date.getTime();				this.projectiles[next].morph = (Math.random() * 1000) + 250;								//set ready_index to the next element				this.ready_index = (next + 1) % this.projectiles.length;								return;			}						next = (next + 1) % this.projectiles.length;		}				//dynamically allocate more memory for pool since it is full!		this.projectiles[this.projectiles.length] = new Projectile(type, x, y, x_vel, y_vel, true);				//track projectile age		var date = new Date();		this.projectiles[this.projectiles.length - 1].birth = date.getTime();		this.projectiles[this.projectiles.length - 1].morph = (Math.random() * 1000) + 250;				//reset ready_index to 0 and hope an earlier projectile deactivates		this.ready_index = 0;				return;	}		ProjectileManager.prototype.update = function(deltaTime)	{		for(var m = 0; m < this.projectiles.length; m++)		{			if(this.projectiles[m].active)			{				//contrail				for(i = TRAIL_LENGTH - 1; i > 0; i--)				{					this.projectiles[m].x[i] = this.projectiles[m].x[i - 1];					this.projectiles[m].y[i] = this.projectiles[m].y[i - 1];				}								//do this.projectiles[m].update() here				switch(this.projectiles[m].type)				{					case 0:					case 1:						this.projectiles[m].x[0] += (this.projectiles[m].x_vel * deltaTime);						this.projectiles[m].y[0] += (this.projectiles[m].y_vel * deltaTime);					break;										case 2:						this.projectiles[m].x[0] += (this.projectiles[m].x_vel * deltaTime);						this.projectiles[m].y[0] += (this.projectiles[m].y_vel * deltaTime);												var date = new Date();						var timestamp = date.getTime();												if(this.projectiles[m].birth + this.projectiles[m].morph < timestamp)						{							this.projectiles[m].x_vel = -this.projectiles[m].x_vel;							this.projectiles[m].birth = timestamp;						}					break;										case 3:											break;										default:					break;				}								if((this.projectiles[m].x[TRAIL_LENGTH - 1] < 0) || (this.projectiles[m].x[TRAIL_LENGTH - 1] > 1024)||					(this.projectiles[m].y[TRAIL_LENGTH - 1] < 0) || (this.projectiles[m].y[TRAIL_LENGTH - 1] > 12 * 256))				{					this.projectiles[m].active = false;				}			}		}				return;	}		ProjectileManager.prototype.TRAIL_LENGTH = TRAIL_LENGTH;		window.ProjectileManager = ProjectileManager;		return; })();